use std::String
use std::Int
use std::println
use std::print
use std::Option
use std::Result

trait Test {
    fn another()
}

struct Box[T](T)

trait New {
    fn new(): Self
}

impl[T] New for Box[T] {
    fn new(): Box[T] {
        Box(x)
    }
}

trait Pushable[T] {
    fn Self.push(x: T)
}

impl[T] Pushable[T] for Box[T] {
    fn Self.push(x: T) {}
}

fn test(thing: Test) {
    let other = 123
    let test: std::Vec[String] = std::Vec
    let some = Option::Some(123)
    let ty = some.unwrap()
    let box = Box::new()
    box.push(123)
    box
}

struct Basic {
    test: Int,
    test2: String
}

fn thingy(x: Option[String]) {
    let basic = Basic(123, "hello")
    let some_basic = Option::Some(basic)
}

impl Basic {
    fn hello() {
        println("Hello")
    }
    fn complex[T](x: T) {
        println("Complex")
    }
}

fn test3(thing: Int) {
    let some = Option::Some(thing)
    some.unwrap()
}

fn test123() {
    let test = std::Vec
}

impl ToString for Basic {
    fn to_string(): String {
        "Hello"
    }
}

impl ToString {
    fn print() {
        println("Hello")
    }
}

trait ToString {
    fn to_string(): String {
        "Hello"
    }
}

trait Clone {
    fn clone(): Self {}
}

impl Clone for Basic {
    fn clone(): Basic {}
}

use gib_mod::another

struct Thing {
  name: String,
  age: Int,
}

trait Magic
trait Epic
trait Spooky

enum Result[out T, out E] {
  Ok(T),
  Err(E),
}

struct Test

impl Magic for Test
impl Epic for Test


impl Magic for Thing {
  fn do_magic() {
    println("Magic!")
  }
}

impl Epic for Thing {
  fn do_epic() {
    println("Epic!")
  }
}

impl Spooky for Thing {
  fn do_spooky() {
    println("Spooky!")
  }
}

enum Option[out T] {
  Some(T),
  None,
}

struct Test2 {
  name: another::Test3,
  age: Magic,
}


fn main() {
  let res: Result[Int, String] = Result::Ok(5)
  let test: String = res
}

fn my_tuple(): (String, String) {
}


fn String.to_string(): String {

}

fn test(hello: String, world: Int): Thing {
}

trait Display {
  fn Self.to_string(): String
}

fn print_string(text: String)

fn print[T: Display](item: T) {
  print_string(123.my_tuple())
}

struct List[out T]

trait Construct {
  fn new() -> Self
}

impl [T] Construct for List[T]  {
  fn new() -> List[T] {
    List
  }
}

fn main() {
  let vals = List::new()
}


use std::String
use std::Int
use std::println
use std::print
use std::Option
use std::Result
use std::panic
use std::Bool

trait Test {
    fn another()
}

struct Box[T](T)

trait New {
    fn new(): Self
}

impl[T] New for Box[T] {
    fn new(): Box[T] {
        Box(x)
    }
}

trait Pushable[T] {
    fn Self.push(x: T)
}

impl[U] Pushable[U] for Box[U] {
    fn Self.push(x: U) {
        println("Pushed")
    }
}

impl From[Int] for String {
    fn from(value: Int): String {
        "Hello"
    }
}

impl From[String] for Int {
    fn from(value: String): Int {
        "Hello"
    }
}

fn test(thing: Test) {
    let other = 123
    let new = std::Vec::new()
    let test = std::Vec::new()
    test.push(other)
    let some = Option::Some(123)
    let transform = { x: Int -> x.add(x) }
    let transformed = some.map(String::from)
    let test = some.unwrap()
    let inner = some.expect("Test")
    let thing = Basic::from("Hello")

}

impl[T] std::Option[T] {
    fn Self.unwrap(): T {
        match self {
            Option::Some(inner) => inner,
            Option::None => panic("Called unwrap on None")
        }
    }
    fn Self.expect(text: String): T {
        match self {
            Option::Some(res) => res,
            Option::None => panic(text)
        }
    }
    fn Self.map[U: String](f: (T) -> U): Option[U] {
        match self {
            Option::Some(inner) => Option::Some(f(inner)),
            Option::None => Option::None
        }
    }
}

struct Basic {
    test: Int,
    test2: String
}

fn thingy(x: Option[String]) {
    let basic = Basic(123, "hello")
    let some_basic = Option::Some(basic)
}

impl Basic {
    fn hello() {
        println("Hello")
    }
    fn complex[T](x: T) {
        println("Complex")
    }
}

fn test3(thing: Int) {
    let some = Option::Some(thing)
    some.unwrap()
}

fn test123() {
    let test = std::Vec
    test.push(123)
}

impl ToString for Basic {
    fn Self.to_string(): String {
        "Hello"
    }
}

impl ToString {
    fn print() {
        println("Hello")
    }
}

trait ToString {
    fn Self.to_string(): String
}

trait Clone {
    fn clone(): Self {}
}

impl Clone for Basic {
    fn clone(): Basic {}
}

impl ToString for Option[String] {
    fn Self.to_string(): String {}
}

trait Into[T] {
    fn Self.into(): T
}

trait From[T] {
    fn from(value: T): Self
}

impl From[String] for Basic {
    fn from(value: String): Self
}

impl Into[String] for Basic {
    fn Basic.into(): String {
        self.to_string()
    }
}

trait Eq {
    fn Self.eq(other: Self): Bool
}

impl Eq for Basic {
    fn Self.eq(other: Self): Bool {
        self.test == other.test
    }
}

impl[T] Option[T] {
    fn Self.unwrap(): T {
        match self {
            Option::Some(res) => res,
            Option::None => panic("Unwrapped None")
        }
    }
}

fn main() {
    let x = Option::None
    let y = x.unwrap()
    let Option::Some(z) = y
    1.add(z)
}
